<style>
    .library-sidebar {
        background-color: #161B22;
        padding: 10px 20px 30px 20px;
        height: calc(100vh - 50px);
        border-right: 1px solid #30363D;
        display: flex;
        flex-direction: column;
    }
    .library-content {
        padding: 20px;
        height: calc(100vh - 50px);
        background-color: #0D1117;
        overflow-y: auto;
    }
    .file-explorer {
        background-color: #0D1117;
        border: 1px solid #30363D;
        border-radius: 6px;
        padding: 0 16px 16px; /* 修改上边距为0，其他保持16px */
        color: #C9D1D9;
        flex: 1;
        overflow-y: auto;
    }
    .file-explorer > .floating-nav-bar {
        margin: 0 -16px 16px -16px; /* 导航栏贴合容器顶部 */
    }
    .file-explorer::-webkit-scrollbar {
        width: 8px;
    }
    .file-explorer::-webkit-scrollbar-track {
        background: #0D1117;
    }
    .file-explorer::-webkit-scrollbar-thumb {
        background-color: #30363D;
        border-radius: 4px;
        border: 2px solid #0D1117;
    }
    .file-explorer::-webkit-scrollbar-thumb:hover {
        background-color: #58A6FF;
    }
    .file-explorer .list-group {
        margin-bottom: 0;
    }
    .file-explorer .list-group-item {
        background-color: transparent;
        border: none;
        color: #C9D1D9;
        cursor: pointer;
        padding: 8px 12px;
        border-radius: 4px;
        margin-bottom: 2px;
        transition: background-color 0.2s;
        display: flex;
        align-items: flex-start;
    }
    .file-explorer .list-group-item .form-check-input {
        margin-top: 0.3rem;
        flex-shrink: 0;
        width: 1.1em;
        height: 1.1em;
        min-width: 1.1em;
    }
    .file-explorer .list-group-item .badge {
        margin-top: 0.2rem;
    }
    .file-explorer .list-group-item:hover {
        background-color: #21262D;
    }
    .file-explorer .list-group-item.active {
        background-color: #0969DA;
    }
    .file-explorer .list-group-item i {
        color: #8B949E;
        width: 16px;
        text-align: center;
        flex-shrink: 0;
    }
    .file-explorer .list-group-item.video-item {
        border-left: 3px solid transparent;
    }
    .file-explorer .list-group-item.video-item:hover {
        border-left-color: #0d6efd;
    }
    .file-info-container {
        min-width: 0;
    }
    .storage-usage {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #30363D;
    }
    .progress-circle {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background: conic-gradient(#0d6efd var(--usage-percent), #30363D 0);
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
    }
    .progress-circle::before {
        content: '';
        position: absolute;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background-color: #161B22;
    }
    .progress-circle span {
        position: relative;
        font-size: 0.8rem;
        font-weight: bold;
    }
    .breadcrumb {
        background-color: transparent;
        padding: 0;
        margin-bottom: 16px;
    }
    .breadcrumb-item {
        color: #8B949E;
    }
    .breadcrumb-item.active {
        color: #C9D1D9;
    }
    .breadcrumb-item a {
        color: #58A6FF;
        text-decoration: none;
    }
    .breadcrumb-item a:hover {
        text-decoration: underline;
    }
    .file-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 16px;
    }
    .file-card {
        background-color: #161B22;
        border: 1px solid #30363D;
        border-radius: 8px;
        padding: 16px;
        cursor: pointer;
        transition: all 0.2s;
        height: 200px;
        display: flex;
        flex-direction: column;
    }
    .file-card:hover {
        background-color: #21262D;
        border-color: #58A6FF;
    }
    .file-card.video-card {
        position: relative;
    }
    .file-card .file-icon {
        font-size: 3rem;
        color: #8B949E;
        margin-bottom: 12px;
        text-align: center;
    }
    .file-card .file-name {
        color: #C9D1D9;
        font-size: 0.85rem; /* 稍微减小字体大小 */
        text-align: center;
        overflow: hidden;
        display: -webkit-box;
        -webkit-line-clamp: 2; /* 限制最多显示2行 */
        -webkit-box-orient: vertical;
        line-height: 1.3; /* 设置行高 */
        max-height: 2.6em; /* 2行文本的最大高度 */
        word-break: break-all; /* 允许在任何字符处换行 */
        padding: 0 4px; /* 添加一些水平内边距 */
        white-space: normal; /* 允许换行 */
    }
    .file-card .file-name .common-prefix,
    .file-card .file-name .common-suffix,
    .file-card .file-name .common-part,
    .list-group-item .common-part,
    .video-info .common-part {
        color: #8B949E;
        font-weight: normal;
    }

    .file-card .file-name .unique-part,
    .list-group-item .unique-part,
    .video-info .unique-part {
        color: #58A6FF;
        font-weight: bold;
    }
    .file-card .file-size {
        color: #8B949E;
        font-size: 0.8rem;
        text-align: center;
        margin-top: auto;
    }
    .file-card .play-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.2s;
    }
    .file-card:hover .play-overlay {
        opacity: 1;
    }
    .loading-spinner {
        text-align: center;
        padding: 20px;
    }
    .error-message {
        color: #f85149;
        text-align: center;
        padding: 20px;
    }
    .video-player {
        width: 100%;
        height: 60vh;
        background-color: #000;
        border-radius: 8px;
        margin-bottom: 16px;
    }
    .video-container.is-fullscreen .video-player {
        border-radius: 0;
    }
    .video-info {
        background-color: #161B22;
        border: 1px solid #30363D;
        border-radius: 8px;
        padding: 16px;
    }
    .video-container {
        position: relative;
    }
    .close-video-btn {
        position: absolute;
        top: 15px;
        left: calc(100% - 55px);
        font-size: 2rem;
        color: white;
        background-color: rgba(0, 0, 0, 0.5);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        line-height: 1;
        padding: 0;
        text-align: center;
        cursor: pointer;
        z-index: 9999 !important;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .close-video-btn:hover {
        background-color: rgba(0, 0, 0, 0.8);
    }
    .video-controls {
        background-color: #161B22;
        border: 1px solid #30363D;
        border-radius: 8px;
        padding: 12px;
        margin-top: 10px;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
        color: #C9D1D9;
    }
    .video-control-item {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .video-control-input {
        background-color: #0D1117;
        border: 1px solid #30363D;
        color: #C9D1D9;
        border-radius: 4px;
        padding: 4px 8px;
        width: 70px;
    }
    .video-control-input:focus {
        border-color: #58A6FF;
        outline: none;
    }
    .form-switch .form-check-input {
        background-color: #30363D;
        border-color: #30363D;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='%238B949E'/%3e%3c/svg%3e");
    }
    .form-switch .form-check-input:checked {
        background-color: #1f6feb;
        border-color: #1f6feb;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='%23ffffff'/%3e%3c/svg%3e");
    }
    .video-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 20;
        border-radius: 8px;
        color: white;
    }
    /* 提高 text-muted 在深色背景下的可读性 */
    .library-sidebar .text-muted,
    .library-content .text-muted {
        color: #8B949E !important; /* 使用一个更亮的灰色 */
    }
    .video-info .text-muted {
        color: #8B949E !important;
    }
    /* 悬浮导航栏样式 */
    .floating-nav-bar {
        position: sticky;
        top: 0;
        z-index: 100;
        background-color: #161B22; /* 与侧边栏背景色相同 */
        border-bottom: 1px solid #30363D; /* 添加底部边框 */
        padding: 12px 16px; /* 调整内边距 */
        margin: 0 -16px 16px -16px; /* 调整边距，使其贴合容器边界 */
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); /* 添加阴影效果 */
        backdrop-filter: blur(8px); /* 添加模糊效果 */
    }
    /* 重置 .row 的上边距 */
    /* .container-fluid > .row {
        margin-top: 0 !important;
    } */
    /* 设置 .container-fluid 的内边距为 10px */
    .container-fluid {
        padding: 4px !important;
    }
    #subtitleSelect {
        min-width: 120px;
        background-color: #0D1117;
        border: 1px solid #30363D;
        color: #C9D1D9;
        border-radius: 4px;
        padding: 4px 8px;
    }
    #subtitleSelect:focus {
        border-color: #58A6FF;
        outline: none;
    }
    /* 颜色选择器样式 */
    .color-input {
        width: 50px !important;
        height: 32px;
        padding: 2px 4px !important;
        background-color: #0D1117;
        border: 1px solid #30363D;
        border-radius: 4px;
        cursor: pointer;
    }
    .color-input:focus {
        border-color: #58A6FF;
        outline: none;
    }
    /* 颜色选择器在 Webkit 浏览器中的样式优化 */
    .color-input::-webkit-color-swatch-wrapper {
        padding: 0;
    }
    .color-input::-webkit-color-swatch {
        border: none;
        border-radius: 2px;
    }
</style>
<div class="container-fluid">
    <div class="row">
        <div class="col-md-3 library-sidebar">
            <div class="file-explorer">
                <div class="floating-nav-bar d-flex justify-content-between align-items-center mb-3">
                    <div class="d-flex align-items-center">
                        <button class="btn btn-sm btn-outline-secondary me-2" id="backBtn" disabled>
                            <i class="bi bi-arrow-left"></i>
                        </button>
                        <button class="btn btn-sm btn-outline-secondary me-2" id="refreshBtn">
                            <i class="bi bi-arrow-clockwise"></i>
                        </button>
                        <button class="btn btn-sm btn-outline-danger me-2" id="deleteBtn" disabled>
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                    <div class="dropdown">
                        <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" id="sortTypeDropdown" data-bs-toggle="dropdown">
                            <i class="bi bi-sort-down"></i> 按名称排序
                        </button>
                        <ul class="dropdown-menu dropdown-menu-end">
                            <li><a class="dropdown-item" href="#" data-sort="name">按名称排序</a></li>
                            <li><a class="dropdown-item" href="#" data-sort="structure">按结构排序</a></li>
                            <li><a class="dropdown-item" href="#" data-sort="episode">按集号排序</a></li>
                        </ul>
                    </div>
                </div>
                <div class="d-flex align-items-center mb-2">
                    <input type="checkbox" class="form-check-input me-2" id="selectAllCheckbox">
                    <label for="selectAllCheckbox" class="form-check-label">全选</label>
                </div>
                <ul class="list-group" id="fileList">
                    <div class="loading-spinner">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">加载中...</span>
                        </div>
                    </div>
                </ul>
            </div>
        </div>
        <div class="col-md-9 library-content">
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb" id="breadcrumb">
                    <li class="breadcrumb-item active">加载中...</li>
                </ol>
            </nav>
            <div id="contentArea">
                <div class="d-flex justify-content-center align-items-center h-100">
                    <div class="text-center">
                        <i class="bi bi-collection-play" style="font-size: 5rem; color: #8B949E;"></i>
                        <p class="text-muted">从您的 OpenList/Alist 服务器浏览文件</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/artplayer/dist/artplayer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/hls.js/dist/hls.min.js"></script>
<script src="/static/js/file-sorter.js"></script>
<script>
let currentPath = '/';
let currentFiles = [];
let isVideoPlaying = false;
let libraryInitialized = false;
let selectedFiles = new Set();
let playerSettings = {
    autoNext: false,
    skipStart: 0,
    skipEnd: 0,
    subtitleSize: 20,
    subtitleColor: '#FFFFFF'
};
let fileSorter = new FileSorter('name'); // 默认按名称排序
let isRequestingVideo = false;
let currentPlayFile = null;
let art = null; // ArtPlayer instance

// 单一播放会话控制：用于避免并发请求和多实例占用资源
let playSessionId = 0;
let currentPlaySession = null; // { id, fileName, path, state, cancelSource }

// 字幕管理器状态
const subtitleState = {
    sessionId: null,
    availableSubtitles: [],
    currentSubtitleId: null,
    cancelled: false,
    currentBlobUrl: null
};

// 页面显示时初始化
document.addEventListener('showPage', function(event) {
    if (event.detail.pageId === 'library') {
        setTimeout(initLibrary, 100); // 延迟一点时间确保DOM完全加载
    }
});

// 也检查页面是否已经可见
if (document.getElementById('library') && document.getElementById('library').style.display !== 'none') {
    setTimeout(initLibrary, 100);
}

// 添加 MutationObserver 来监听页面显示状态变化
const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
            const libraryPage = document.getElementById('library');
            if (libraryPage && libraryPage.style.display !== 'none') {
                setTimeout(initLibrary, 100);
                observer.disconnect(); // 只执行一次
            }
        }
    });
});

// 开始观察 library 页面的 style 属性变化
const libraryPage = document.getElementById('library');
if (libraryPage) {
    observer.observe(libraryPage, { attributes: true });
}

// 添加一个简单的点击测试
document.addEventListener('DOMContentLoaded', function() {
    console.log('Library page loaded');
    
    // 为 library 标签添加点击监听器作为备用
    const libraryNavLink = document.querySelector('[data-page="library"]');
    if (libraryNavLink) {
        console.log('Found library nav link, adding click listener');
        libraryNavLink.addEventListener('click', function(e) {
            console.log('Library nav link clicked');
            setTimeout(initLibrary, 200);
        });
    }
});

function initLibrary() {
    if (libraryInitialized) {
        return;
    }
    libraryInitialized = true;
    console.log('Initializing library...');
    loadSortSettings(); // 加载排序设置
    loadPlayerSettings(); // 加载播放器设置
    loadFileList(currentPath);
    
    // 事件监听
    const backBtn = document.getElementById('backBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    
    const deleteBtn = document.getElementById('deleteBtn');
    const selectAllCheckbox = document.getElementById('selectAllCheckbox');

    if (backBtn) {
        backBtn.addEventListener('click', goBack);
    }
    if (refreshBtn) {
        refreshBtn.addEventListener('click', () => loadFileList(currentPath, true));
    }
    if (deleteBtn) {
        deleteBtn.addEventListener('click', deleteSelectedFiles);
    }
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', toggleSelectAll);
    }
    
    // 添加转存成功事件监听器
    window.addEventListener('quarkTransferSuccess', handleTransferSuccess);
    
    // 添加排序方式切换事件监听器
    setupSortTypeDropdown();
}

// 设置排序方式下拉菜单
function setupSortTypeDropdown() {
    document.querySelectorAll('[data-sort]').forEach(item => {
        item.addEventListener('click', function(e) {
            e.preventDefault();
            const sortType = this.getAttribute('data-sort');
            fileSorter.setSortType(sortType);
            saveSortSettings(sortType); // 保存排序设置到本地存储
            updateSortButton(sortType); // 更新按钮文本
            
            // 重新排序并显示
            if (currentFiles && currentFiles.length > 0) {
                currentFiles = fileSorter.sort(currentFiles);
                displayFileList(currentFiles);
                displayFileGrid(currentFiles);
            }
        });
    });
}

// 处理转存成功事件
function handleTransferSuccess(event) {
    console.log('收到转存成功事件:');
    
    // 刷新当前目录
    loadFileList(currentPath, true);
}




function loadFileList(path, refresh = false) {
    currentPath = path;
    
    selectedFiles.clear();
    updateDeleteButtonState();
    document.getElementById('selectAllCheckbox').checked = false;

    // 更新UI状态
    document.getElementById('backBtn').disabled = path === '/';
    
    // 显示加载状态
    const fileList = document.getElementById('fileList');
    fileList.innerHTML = `
        <div class="loading-spinner">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">加载中...</span>
            </div>
        </div>
    `;
    
    // 更新面包屑
    updateBreadcrumb(path);
    
    axios.post('/api/library/fs/list', { path: path, refresh: refresh })
        .then(response => {
            if (response.data.success) {
                currentFiles = response.data.data.content || [];
                
                // 【关键】在这里对 currentFiles 进行一次排序（使用 FileSorter）
                currentFiles = fileSorter.sort(currentFiles);

                displayFileList(currentFiles);
                displayFileGrid(currentFiles);
            } else {
                    

                // 特殊处理：如果后端返回 storage not found，视为新用户空目录，不报错
                if (response.data.message && response.data.message.includes('object not found') && "/" === path.trim()) {
                    console.log('Storage not found, treating as empty directory (new user)');
                    currentFiles = [];
                    displayFileList(currentFiles);
                    displayFileGrid(currentFiles);
                } else {
                    showError('加载文件失败: ' + response.data.message);
                }
            }
        })
        .catch(error => {
            console.error('Error loading file list:', error);
            showError('加载文件失败');
        });
}

function displayFileList(files) {
    const fileList = document.getElementById('fileList');
    
    if (files.length === 0) {
        fileList.innerHTML = '<div class="text-center text-muted p-3">空目录</div>';
        return;
    }
    
    let html = '';

    // 【修改】移除这里的排序逻辑，直接使用传入的已排序files
    files.forEach(file => {
        const icon = file.is_dir ? 'bi-folder' : getFileIcon(file.name);
        const size = file.is_dir ? '' : formatBytes(file.size);
        
        let displayName = file.name;
        if (!file.is_dir && isVideoFile(file.name)) {
            const nameResult = fileSorter.highlightFileName(file.name);
            displayName = typeof nameResult === 'string' ? nameResult : nameResult.html;
        }

        html += `
            <li class="list-group-item ${!file.is_dir && isVideoFile(file.name) ? 'video-item' : ''}" onclick="handleFileClick('${file.name}', ${file.is_dir}, event)">
                <input type="checkbox" class="form-check-input me-2 file-checkbox" value="${file.name}" onchange="handleFileSelection()">
                <div class="flex-grow-1 d-flex align-items-start file-info-container">
                    <i class="bi ${icon} me-2 mt-1"></i>
                    <span title="${file.name}" style="word-break: break-all;">${displayName}</span>
                </div>
                ${size ? `<span class="badge bg-secondary ms-auto">${size}</span>` : ''}
            </li>
        `;
    });
    
    fileList.innerHTML = html;
}

function displayFileGrid(files) {
    if (isVideoPlaying) {
        return;
    }
    const contentArea = document.getElementById('contentArea');
    
    if (files.length === 0) {
        contentArea.innerHTML = `
            <div class="d-flex justify-content-center align-items-center h-100">
                <div class="text-center">
                    <i class="bi bi-folder-x" style="font-size: 5rem; color: #8B949E;"></i>
                    <p class="text-muted">空目录</p>
                </div>
            </div>
        `;
        return;
    }
    
    // 只显示视频文件
    const videoFiles = files.filter(file => !file.is_dir && isVideoFile(file.name));
    
    if (videoFiles.length === 0) {
        contentArea.innerHTML = `
            <div class="d-flex justify-content-center align-items-center h-100">
                <div class="text-center">
                    <i class="bi bi-film" style="font-size: 5rem; color: #8B949E;"></i>
                    <p class="text-muted">此目录中没有视频文件</p>
                </div>
            </div>
        `;
        return;
    }
    
    let html = '<div class="file-grid">';
    
    videoFiles.forEach(file => {
        html += `
            <div class="file-card video-card" onclick="playVideo('${file.name}')">
                <div class="file-icon">
                    <i class="bi ${getFileIcon(file.name)}"></i>
                </div>
                <div class="play-overlay">
                    <i class="bi bi-play-fill"></i>
                </div>
                <div class="file-name">${file.name}</div>
                <div class="file-size">${formatBytes(file.size)}</div>
            </div>
        `;
    });
    
    html += '</div>';
    contentArea.innerHTML = html;
}

function handleFileClick(fileName, isDir, event) {
    // 防止点击 Checkbox 时触发导航
    if (event && event.target.type === 'checkbox') {
        return;
    }
    if (isDir) {
        // 如果是上级目录
        if (fileName === '..') {
            navigateToParent();
            return;
        }
        navigateToDirectory(fileName);
    } else {
        if (isVideoFile(fileName)) {
            playVideo(fileName);
        }
    }
}

function navigateToDirectory(dirName) {
    const newPath = currentPath === '/' ? `/${dirName}` : `${currentPath}/${dirName}`;
    loadFileList(newPath);
}

function navigateToParent() {
    const parentPath = currentPath.substring(0, currentPath.lastIndexOf('/'));
    loadFileList(parentPath === '' ? '/' : parentPath);
}

function goBack() {
    navigateToParent();
}

function updateBreadcrumb(path) {
    const breadcrumb = document.getElementById('breadcrumb');
    const parts = path.split('/').filter(part => part);
    
    let html = '<li class="breadcrumb-item"><a href="#" onclick="loadFileList(\'/\')">主页</a></li>';
    
    let currentPath = '';
    parts.forEach((part, index) => {
        currentPath += '/' + part;
        if (index === parts.length - 1) {
            html += `<li class="breadcrumb-item active">${part}</li>`;
        } else {
            html += `<li class="breadcrumb-item"><a href="#" onclick="loadFileList('${currentPath}')">${part}</a></li>`;
        }
    });
    
    breadcrumb.innerHTML = html;
}

function _createProxyUrl(originalUrl) {
    // 【修改这里】使用您刚刚部署的 Deno Deploy 地址
    return `https://quarkurlproxy.deno.dev?url=${encodeURIComponent(originalUrl)}`;
}

// 获取视频下载链接的封装函数
function getVideoDownloadUrl(filePath, sessionId = null) {
    return new Promise((resolve, reject) => {
        let axiosConfig = undefined;
        
        // 使用 axios.CancelToken（如果可用）支持取消请求
        if (typeof axios !== 'undefined' && axios.CancelToken && sessionId) {
            const cancelSource = axios.CancelToken.source();
            if (currentPlaySession && currentPlaySession.id === sessionId) {
                currentPlaySession.cancelSource = cancelSource;
            }
            axiosConfig = { cancelToken: cancelSource.token };
        }
        
        axios.post('/api/library/fs/download', { path: filePath }, axiosConfig)
            .then(response => {
                if (response.data.success) {
                    resolve({
                        url: response.data.data.download_url,
                        isM3U8: response.data.data.download_url.includes('.m3u8')
                    });
                } else {
                    reject(new Error(response.data.message || '获取视频地址失败'));
                }
            })
            .catch(error => {
                // 主动取消请求的场景，静默处理
                if (typeof axios !== 'undefined' && axios.isCancel && axios.isCancel(error)) {
                    console.log('Video request canceled for session', sessionId, error.message || '');
                    reject(new Error('Request canceled'));
                } else {
                    reject(error);
                }
            });
    });
}

// 处理 HLS 错误的封装函数 - ArtPlayer 内置了 HLS 错误处理，保留作为备用
function setupHLSErrorHandling(art, downloadUrl) {
    if (!art) {
        return;
    }
    
    // ArtPlayer 使用 customType 配置 HLS，错误处理已在初始化时配置
    // 此函数保留用于未来扩展
    console.log('HLS error handling configured in ArtPlayer initialization');
}

// 显示视频错误回退UI的封装函数
function showVideoErrorFallback(downloadUrl) {
    const artplayerContainer = document.getElementById('artplayer');
    if (artplayerContainer) {
        artplayerContainer.innerHTML = `
            <div class="video-loading-overlay" style="background-color: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center;">
                <button class="close-video-btn" onclick="closeVideoPlayer()">&times;</button>
                <i class="bi bi-exclamation-triangle mb-3" style="font-size: 3rem; color: #f85149;"></i>
                <h5>视频加载失败</h5>
                <p class="text-muted mb-4">这可能是由CORS策略或网络问题引起的。您可以尝试在新标签页中打开它。</p>
                <a href="${downloadUrl}" target="_blank" class="btn btn-primary">
                    <i class="bi bi-box-arrow-up-right me-2"></i>点击尝试在新标签页中打开播放
                </a>
            </div>
        `;
    }
}

// 更新视频信息UI的封装函数
function updateVideoInfo(fileName) {
    const displayName = fileSorter.highlightFileName(fileName);
    const videoInfo = document.querySelector('.video-info h5');
    if (videoInfo) {
        videoInfo.innerHTML = typeof displayName === 'string' ? displayName : displayName.html;
        videoInfo.title = fileName;
    }
    
    const videoPath = document.querySelector('.video-info p');
    if (videoPath) {
        videoPath.textContent = `播放路径: ${currentPath}`;
    }
}

// 显示加载状态的封装函数
function showLoadingOverlay(message = '正在加载视频...') {
    const artplayerContainer = document.getElementById('artplayer');
    if (artplayerContainer) {
        const loadingOverlay = document.createElement('div');
        loadingOverlay.className = 'video-loading-overlay';
        loadingOverlay.innerHTML = `
            <div class="spinner-border text-light" role="status"></div>
            <p class="mt-3">${message}</p>
        `;
        artplayerContainer.appendChild(loadingOverlay);
        return loadingOverlay;
    }
    return null;
}

// 取消当前会话的下载请求（如果存在）
function cancelCurrentVideoRequest(reason) {
    if (currentPlaySession && currentPlaySession.cancelSource && typeof currentPlaySession.cancelSource.cancel === 'function') {
        try {
            currentPlaySession.cancelSource.cancel(reason || 'Canceled by new action');
        } catch (e) {
            console.error('Failed to cancel previous video request:', e);
        } finally {
            currentPlaySession.cancelSource = null;
        }
    }
}

// 销毁当前 ArtPlayer 实例并清理全局引用
function destroyCurrentPlayer() {
    if (art) {
        try {
            // 停止播放
            art.pause();
            art.url = ''; // 清空URL
            
            // 【关键】停止视频元素的加载 - 对于非 HLS 视频
            if (art.video) {
                art.video.pause();
                art.video.removeAttribute('src');
                art.video.load();
                art.video.src = '';
            }
            
            // 清理HLS实例
            if (art.hls) {
                art.hls.destroy();
                art.hls = null;
            }
            
            // 销毁实例
            art.destroy();
        } catch (e) {
            console.error('An error occurred during ArtPlayer destruction:', e);
        } finally {
            art = null;
        }
    }
}

// ========== 字幕相关函数 ==========

// 查找匹配的字幕
function findMatchingSubtitles(videoFileName) {
    if (!currentFiles || currentFiles.length === 0) return [];
    
    const subtitleExtensions = ['vtt', 'srt', 'ass', 'ssa', 'sub'];
    const videoNameWithoutExt = videoFileName.replace(/\.[^/.]+$/, '');
    
    return currentFiles
        .filter(file => !file.is_dir && subtitleExtensions.some(ext => file.name.toLowerCase().endsWith('.' + ext)))
        .map(file => {
            const ext = file.name.split('.').pop().toLowerCase();
            const subtitleNameWithoutExt = file.name.replace(/\.[^/.]+$/, '');
            let matchType = null;
            let language = 'unknown';
            
            if (subtitleNameWithoutExt === videoNameWithoutExt) {
                matchType = 'exact';
            } else {
                const langPatterns = ['zh-cn', 'zh-tw', 'zh-hk', 'zh', 'en', 'chs', 'cht', 'chs-chn', 'zho'];
                for (const langCode of langPatterns) {
                    if (subtitleNameWithoutExt.toLowerCase().endsWith('.' + langCode)) {
                        matchType = 'language';
                        language = langCode;
                        break;
                    }
                }
            }
            
            if (matchType) {
                return {
                    id: file.name,
                    name: file.name,
                    fid: file.raw_fid,
                    format: ext,
                    language: language,
                    matchType: matchType
                };
            }
            return null;
        })
        .filter(Boolean);
}

// 渐进增强策略加载字幕
// 1. 首先尝试直接使用原始 URL
// 2. 如果加载失败，回退到 Blob URL 方案
async function loadSubtitleToPlayer(subtitle, sessionId) {
    if (subtitleState.sessionId !== sessionId || !art) return;
    
    try {
        const filePath = currentPath === '/' ? `/${subtitle.name}` : `${currentPath}/${subtitle.name}`;
        const { url } = await getVideoDownloadUrl(filePath, sessionId);
        
        if (subtitleState.sessionId !== sessionId) return;
        
        // 渐进增强策略：先尝试直接使用原始 URL
        const directLoadSuccess = await tryDirectSubtitleLoad(url, sessionId);
        
        // 如果直接加载成功，保存原始 URL 作为当前字幕
        if (directLoadSuccess) {
            subtitleState.currentBlobUrl = null; // 使用原始 URL，不需要 Blob
            // 应用当前的字幕样式设置
            applySubtitleSettings();
            return;
        }
        
        // 直接加载失败，回退到 Blob URL 方案
        console.log('Direct subtitle load failed, falling back to Blob URL');
        await loadSubtitleWithBlob(url, subtitle, sessionId);
        // 应用当前的字幕样式设置
        applySubtitleSettings();
    } catch (error) {
        console.error('Failed to load subtitle:', error);
    }
}

// 尝试直接使用原始 URL 加载字幕
async function tryDirectSubtitleLoad(url, sessionId) {
    if (subtitleState.sessionId !== sessionId || !art) return false;
    
    try {
        // 验证 URL 是否可以正常请求（检测跨域等问题）
        const response = await fetch(url, { method: 'HEAD' });
        if (!response.ok) {
            console.warn('Subtitle URL not accessible:', response.status);
            return false;
        }
        
        // 直接使用原始 URL
        if (art.subtitle) {
            art.subtitle.switch(url);
            art.subtitle.show = true;
            console.log('Subtitle loaded directly from URL');
            return true;
        }
    } catch (error) {
        // fetch 失败（可能是跨域），返回 false 进行回退
        console.warn('Direct subtitle load failed:', error.message);
        return false;
    }
    
    return false;
}

// Blob URL 方案加载字幕（回退方案）
async function loadSubtitleWithBlob(url, subtitle, sessionId) {
    if (subtitleState.sessionId !== sessionId || !art) return;
    
    try {
        // 使用 fetch 获取字幕内容
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Failed to fetch subtitle: ${response.status}`);
        }
        const arrayBuffer = await response.arrayBuffer();
        
        if (subtitleState.sessionId !== sessionId) return;
        
        // 根据字幕格式进行差异化处理
        const format = subtitle.format.toLowerCase();
        const decodedContent = detectAndDecodeSubtitle(arrayBuffer);
        let blobContent;
        let mimeType;
        
        if (format === 'srt') {
            // SRT 格式：需要转换为 VTT
            blobContent = srtToVtt(decodedContent);
            mimeType = 'text/vtt';
        } else if (format === 'vtt') {
            // VTT 格式：直接使用
            blobContent = decodedContent;
            mimeType = 'text/vtt';
        } else if (format === 'ass' || format === 'ssa') {
            // ASS/SSA 格式：转换为 VTT
            blobContent = assToVtt(decodedContent);
            mimeType = 'text/vtt';
        } else if (format === 'sub') {
            // SUB 格式：暂不支持
            console.warn('SUB format is not supported yet');
            return;
        } else {
            // 其他格式：尝试作为普通文本处理
            blobContent = decodedContent;
            mimeType = 'text/plain';
        }
        
        // 创建 Blob URL
        const blob = new Blob([blobContent], { type: mimeType });
        const blobUrl = URL.createObjectURL(blob);
        
        // 释放旧的 Blob URL
        if (subtitleState.currentBlobUrl) {
            URL.revokeObjectURL(subtitleState.currentBlobUrl);
        }
        subtitleState.currentBlobUrl = blobUrl;
        
        if (art.subtitle) {
            art.subtitle.switch(blobUrl);
            art.subtitle.show = true;
        }
        console.log('Subtitle loaded via Blob URL');
    } catch (error) {
        console.error('Failed to load subtitle via Blob:', error);
    }
}

// 改进的编码检测与解码函数
function detectAndDecodeSubtitle(arrayBuffer) {
    // 首先尝试 UTF-8 解码
    const utf8Decoder = new TextDecoder('utf-8');
    const utf8Text = utf8Decoder.decode(arrayBuffer);
    
    // 检测是否包含无效的 Unicode 替换字符（� 或 U+FFFD）
    // 这是判断是否被错误解码的关键指标
    const hasInvalidChars = utf8Text.includes('\uFFFD') || /[\x00-\x08\x0B\x0C\x0E-\x1F]/.test(utf8Text);
    
    // 如果没有无效字符，认为是有效的 UTF-8，直接返回
    if (!hasInvalidChars) {
        return utf8Text;
    }
    
    // 如果 UTF-8 解码结果包含无效字符，尝试 GBK 解码
    try {
        const gbkDecoder = new TextDecoder('gbk');
        const gbkText = gbkDecoder.decode(arrayBuffer);
        
        // 检查 GBK 解码后是否仍然包含无效字符
        const gbkHasInvalidChars = gbkText.includes('\uFFFD') || /[\x00-\x08\x0B\x0C\x0E-\x1F]/.test(gbkText);
        
        if (!gbkHasInvalidChars) {
            console.log('Detected GBK encoding, converted successfully');
            return gbkText;
        }
    } catch (e) {
        console.warn('GBK decode failed:', e);
    }
    
    // 如果 GBK 也失败，尝试 GB18030（更广泛的汉字编码）
    try {
        const gb18030Decoder = new TextDecoder('gb18030');
        const gb18030Text = gb18030Decoder.decode(arrayBuffer);
        const gb18030HasInvalidChars = gb18030Text.includes('\uFFFD') || /[\x00-\x08\x0B\x0C\x0E-\x1F]/.test(gb18030Text);
        
        if (!gb18030HasInvalidChars) {
            console.log('Detected GB18030 encoding, converted successfully');
            return gb18030Text;
        }
    } catch (e) {
        console.warn('GB18030 decode failed:', e);
    }
    
    // 如果所有尝试都失败，返回 UTF-8 结果（可能会有乱码，但不会崩溃）
    console.warn('Failed to detect encoding, using UTF-8 fallback');
    return utf8Text;
}

// SRT 转 VTT 格式转换函数
function srtToVtt(srtContent) {
    // 添加 VTT 头部
    let vttContent = 'WEBVTT\n\n';
    
    // 移除 BOM
    const content = srtContent.replace(/^\uFEFF/, '');
    
    // 分割行
    const lines = content.split('\n');
    let vttLines = [];
    let i = 0;
    
    // 时间戳正则表达式
    const timeRegex = new RegExp('(\\d{2}):(\\d{2}):(\\d{2}),(\\d{3})\\s*-->\\s*(\\d{2}):(\\d{2}):(\\d{2}),(\\d{3})');
    
    while (i < lines.length) {
        // 跳过空行
        if (lines[i].trim() === '') {
            i++;
            continue;
        }
        
        // 序号行，跳过
        if (/^\\d+$/.test(lines[i].trim())) {
            i++;
            continue;
        }
        
        // 时间戳行
        const timeMatch = lines[i].match(timeRegex);
        if (timeMatch) {
            const vttTime = `${timeMatch[1]}:${timeMatch[2]}:${timeMatch[3]}.${timeMatch[4]} --> ${timeMatch[5]}:${timeMatch[6]}:${timeMatch[7]}.${timeMatch[8]}`;
            vttLines.push(vttTime);
            i++;
            
            // 合并文本行，直到下一个时间戳
            const nextTimeRegex = new RegExp('\\d{2}:\\d{2}:\\d{2}');
            while (i < lines.length && !nextTimeRegex.test(lines[i])) {
                vttLines.push(lines[i]);
                i++;
            }
            vttLines.push(''); // 空行分隔
        } else {
            i++;
        }
    }
    
    vttContent += vttLines.join('\n');
    return vttContent;
}

// ASS 转 VTT 格式转换函数
function assToVtt(assContent) {
    // 添加 VTT 头部
    let vttContent = 'WEBVTT\n\n';
    
    // 移除 BOM
    const content = assContent.replace(/^\uFEFF/, '');
    
    // 分割行
    const lines = content.split('\n');
    
    // 查找 Events 节的起始位置
    let eventsSectionIndex = -1;
    for (let i = 0; i < lines.length; i++) {
        if (lines[i].trim().toLowerCase().startsWith('[events]')) {
            eventsSectionIndex = i;
            break;
        }
    }
    
    // 如果没有找到 Events 节，尝试直接解析 Dialogue 行
    if (eventsSectionIndex === -1) {
        console.warn('No [Events] section found in ASS file, trying to parse Dialogue lines directly');
    }
    
    // 解析 Dialogue 行
    let vttLines = [];
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // 跳过注释行
        if (line.startsWith('Comment:')) {
            continue;
        }
        
        // 查找 Dialogue 行
        if (line.startsWith('Dialogue:')) {
            const dialogue = parseAssDialogueLine(line);
            if (dialogue && dialogue.text) {
                // 转换时间格式
                const vttTime = `${convertAssTimeToVtt(dialogue.start)} --> ${convertAssTimeToVtt(dialogue.end)}`;
                vttLines.push(vttTime);
                
                // 处理文本内容（清理样式标签）
                const cleanedText = cleanAssStyles(dialogue.text);
                vttLines.push(cleanedText);
                vttLines.push(''); // 空行分隔
            }
        }
    }
    
    vttContent += vttLines.join('\n');
    return vttContent;
}

// 解析 ASS Dialogue 行
function parseAssDialogueLine(line) {
    // 移除 "Dialogue:" 前缀
    const content = line.substring(9).trim();
    
    // 按逗号分割字段
    // ASS Dialogue 格式: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
    const parts = content.split(',');
    
    // 至少需要 10 个字段（最后一个字段 Text 可能包含逗号，需要重新组合）
    if (parts.length < 10) {
        return null;
    }
    
    const layer = parts[0].trim();
    const start = parts[1].trim();
    const end = parts[2].trim();
    const style = parts[3].trim();
    const name = parts[4].trim();
    const marginL = parts[5].trim();
    const marginR = parts[6].trim();
    const marginV = parts[7].trim();
    const effect = parts[8].trim();
    
    // Text 字段可能包含逗号，需要重新组合
    const text = parts.slice(9).join(',').trim();
    
    return {
        layer,
        start,
        end,
        style,
        name,
        marginL,
        marginR,
        marginV,
        effect,
        text
    };
}

// 转换 ASS 时间格式到 VTT 时间格式
// ASS: H:MM:SS.CC 或 HH:MM:SS.CC
// VTT: HH:MM:SS.mmm
function convertAssTimeToVtt(assTime) {
    const parts = assTime.split(':');
    if (parts.length === 3) {
        const hours = parts[0].padStart(2, '0');
        const minutes = parts[1];
        const secondsWithCenti = parts[2];
        const secondsParts = secondsWithCenti.split('.');
        const seconds = secondsParts[0].padStart(2, '0');
        const centiseconds = secondsParts[1] || '00';
        // 将厘秒转换为毫秒：1 厘秒 = 10 毫秒
        const milliseconds = (parseInt(centiseconds) * 10).toString().padStart(3, '0');
        return `${hours}:${minutes}:${seconds}.${milliseconds}`;
    }
    return assTime; // 回退
}

// 清理 ASS 样式标签，保留纯文本
function cleanAssStyles(text) {
    // 替换换行符
    let cleaned = text.replace(/\\n/gi, '\n');
    cleaned = cleaned.replace(/\\N/g, '\n');
    cleaned = cleaned.replace(/\\h/g, ' ');
    
    // 移除样式标签 {\...}
    cleaned = cleaned.replace(/\{\\[^}]+\}/g, '');
    
    // 处理转义字符
    cleaned = cleaned.replace(/\[\\[^\]]+\]/g, '');
    
    return cleaned.trim();
}

// 卸载字幕
function unloadSubtitle() {
    if (art && art.subtitle) {
        art.subtitle.show = false;
    }
    subtitleState.currentSubtitleId = null;
}

// 取消字幕操作
function cancelSubtitleOperations() {
    subtitleState.cancelled = true;
    subtitleState.availableSubtitles = [];
    subtitleState.currentSubtitleId = null;
    
    // 释放 Blob URL
    if (subtitleState.currentBlobUrl) {
        URL.revokeObjectURL(subtitleState.currentBlobUrl);
        subtitleState.currentBlobUrl = null;
    }
}

// 初始化字幕选择控件
function initSubtitleSelector(subtitles, sessionId) {
    const select = document.getElementById('subtitleSelect');
    if (!select) return;
    
    select.innerHTML = '<option value="">无字幕</option>';
    
    subtitles.forEach(sub => {
        const option = document.createElement('option');
        option.value = sub.id;
        option.textContent = sub.name;
        select.appendChild(option);
    });
    
    select.onchange = (e) => {
        if (subtitleState.sessionId !== sessionId) return;
        
        const value = e.target.value;
        if (!value) {
            unloadSubtitle();
        } else {
            const subtitle = subtitles.find(s => s.id === value);
            if (subtitle) {
                loadSubtitleToPlayer(subtitle, sessionId);
                subtitleState.currentSubtitleId = value;
            }
        }
    };
}

// 应用字幕样式设置
function applySubtitleSettings() {
    const sizeInput = document.getElementById('subtitleSizeInput');
    const colorInput = document.getElementById('subtitleColorInput');
    
    if (!sizeInput || !colorInput) return;
    
    const size = parseInt(sizeInput.value) || 20;
    const color = colorInput.value || '#FFFFFF';
    
    // 验证大小范围
    const validSize = Math.max(12, Math.min(60, size));
    
    // 更新输入框显示（如果值被修正）
    if (sizeInput.value != validSize) {
        sizeInput.value = validSize;
    }
    
    // 更新设置对象
    playerSettings.subtitleSize = validSize;
    playerSettings.subtitleColor = color;
    
    // 保存到本地存储
    localStorage.setItem('quark_player_settings', JSON.stringify(playerSettings));
    
    // 如果播放器实例存在，应用样式
    if (art && art.subtitle) {
        // 备用方案：直接修改字幕元素的样式
        applySubtitleStylesDirectly(validSize, color);
    }
}

// 直接应用到字幕元素
function applySubtitleStylesDirectly(size, color) {
    // ArtPlayer 的字幕元素通常在 .art-subtitle 类下
    const subtitleElements = document.querySelectorAll('.art-subtitle');
    subtitleElements.forEach(el => {
        el.style.color = color;
        el.style.fontSize = `${size}px`;
        el.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)';
    });
}

// ========== 字幕相关函数结束 ==========

function playVideo(fileName) {
    // 为新的播放会话生成 id，并终止上一个会话
    playSessionId += 1;
    const sessionId = playSessionId;

    // 确保上一个会话的请求和播放器被清理，避免并发和资源占用
    cancelCurrentVideoRequest('Start new video session');
    // 立即将旧会话标记为失效，避免其异步事件影响新会话 UI
    currentPlaySession = null;
    destroyCurrentPlayer();

    isVideoPlaying = true;
    isRequestingVideo = true; // 设置请求标志，用于 UI 状态
    currentPlayFile = fileName;

    const contentArea = document.getElementById('contentArea');

    // 构造显示名称
    let displayName = fileName;
    const nameResult = fileSorter.highlightFileName(fileName);
    displayName = typeof nameResult === 'string' ? nameResult : nameResult.html;

    // 1. 先显示UI框架和加载状态
    contentArea.innerHTML = `
        <div class="video-container" id="videoContainer">
            <button class="close-video-btn" id="closeVideoBtn" onclick="closeVideoPlayer()">&times;</button>
            <div id="artplayer" class="video-player">
                <div class="video-loading-overlay">
                    <div class="spinner-border text-light" role="status"></div>
                    <p class="mt-3">正在加载视频...</p>
                </div>
            </div>
            <div class="video-controls">
               <div class="video-control-item form-switch">
                    <input class="form-check-input" type="checkbox" id="autoNextSwitch" ${playerSettings.autoNext ? 'checked' : ''} onchange="updatePlayerSetting('autoNext', this.checked)">
                    <label class="form-check-label" for="autoNextSwitch">自动下一集</label>
                </div>
                <div class="video-control-item">
                    <label>跳过片头(秒):</label>
                    <input type="number" class="video-control-input" value="${playerSettings.skipStart}" min="0" onchange="updatePlayerSetting('skipStart', this.value)">
                </div>
                <div class="video-control-item">
                    <label>跳过片尾(秒):</label>
                    <input type="number" class="video-control-input" value="${playerSettings.skipEnd}" min="0" onchange="updatePlayerSetting('skipEnd', this.value)">
                </div>
                <div class="video-control-item">
                    <i class="bi bi-badge-cc"></i>
                    <select id="subtitleSelect" class="video-control-input">
                        <option value="">无字幕</option>
                    </select>
                </div>
                <div class="video-control-item">
                    <label>字幕大小(px):</label>
                    <input type="number" class="video-control-input" id="subtitleSizeInput"
                           value="${playerSettings.subtitleSize}"
                           min="12" max="60"
                           onchange="applySubtitleSettings()">
                </div>
                <div class="video-control-item">
                    <label>字幕颜色:</label>
                    <input type="color" id="subtitleColorInput" class="video-control-input color-input"
                           value="${playerSettings.subtitleColor}" onchange="applySubtitleSettings()">
                </div>
            </div>
            <div class="video-info mt-3">
                <h5 title="${fileName}">${displayName}</h5>
                <p class="text-muted mb-0">播放路径: ${currentPath}</p>
            </div>
        </div>
    `;

    // 2. 使用事件委托为关闭按钮绑定事件（更健壮的方案）
    const videoContainer = document.getElementById('videoContainer');
    if (videoContainer) {
        videoContainer.addEventListener('click', (e) => {
            if (e.target.id === 'closeVideoBtn' || e.target.closest('#closeVideoBtn')) {
                e.preventDefault();
                e.stopPropagation();
                closeVideoPlayer();
            }
        }, { capture: true });
    }

    // 3. 获取视频链接
    const filePath = currentPath === '/' ? `/${fileName}` : `${currentPath}/${fileName}`;

    // 初始化当前会话对象
    currentPlaySession = {
        id: sessionId,
        fileName: fileName,
        path: filePath,
        state: 'RequestingUrl',
        cancelSource: null,
        initialSeekPerformed: false,
        canplayHandled: false
    };

    // 重置字幕状态
    subtitleState.sessionId = sessionId;
    subtitleState.cancelled = false;
    subtitleState.availableSubtitles = [];
    subtitleState.currentSubtitleId = null;

    // 查找匹配的字幕
    const subtitles = findMatchingSubtitles(fileName);
    subtitleState.availableSubtitles = subtitles;

    // 初始化字幕选择控件
    initSubtitleSelector(subtitles, sessionId);
    // 使用封装的函数获取视频下载链接
    getVideoDownloadUrl(filePath, sessionId)
        .then(({ url: downloadUrl, isM3U8 }) => {
            // 如果会话已失效或被新的点击替代，直接忽略结果
            if (!currentPlaySession || currentPlaySession.id !== sessionId) {
                return;
            }

            currentPlaySession.state = 'InitializingPlayer';

            const artplayerContainer = document.getElementById('artplayer');
            if (!artplayerContainer) {
                // UI 已经被关闭或切换，不再初始化播放器
                return;
            }

            // 3. 获取到链接后，再初始化播放器
            art = new Artplayer({
                container: artplayerContainer,
                url: downloadUrl,
                type: isM3U8 ? 'm3u8' : 'auto',
                autoplay: true,
                volume: 0.7,
                isLive: isM3U8,
                fullscreen: true,   // 启用全屏功能
                fullscreenWeb: true, // 启用网页全屏
                setting: true,      // 启用设置菜单
                flip: true,         // 启用翻转功能
                playbackRate: true, // 启用倍速播放
                aspectRatio: true,  // 启用宽高比设置
                autoMini: true,     // 自动小窗口
                screenshot: true,   // 启用截图功能
                miniProgressBar: true, // 迷你进度条
                customType: {
                    m3u8: function (video, url) {
                        const hls = new Hls();
                        hls.loadSource(url);
                        hls.attachMedia(video);
                        
                        // 保存HLS实例到art对象以便后续清理
                        art.hls = hls;
                        
                        // HLS 错误处理
                        hls.on(Hls.Events.ERROR, function (event, data) {
                            console.error('HLS error detected:', data);
                            if (data.fatal && data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                                hls.startLoad();
                            }
                        });
                    }
                }
            });
            
            currentPlaySession.state = 'Playing';

            // 监听播放结束事件以实现自动下一集（仅对当前会话生效）
            art.on('video:ended', () => {
                if (!currentPlaySession || currentPlaySession.id !== sessionId) {
                    return;
                }
                if (playerSettings.autoNext) {
                    playNextVideo(currentPlaySession.fileName);
                }
            });
            

            // 监听时间更新以实现跳过片尾（仅对当前会话生效）
            art.on('video:timeupdate', () => {
                if (!currentPlaySession || currentPlaySession.id !== sessionId) {
                    return;
                }
                if (playerSettings.skipEnd > 0 && art.duration > 0) {
                    if (art.currentTime >= art.duration - playerSettings.skipEnd) {
                        if (playerSettings.autoNext) {
                            playNextVideo(currentPlaySession.fileName);
                        }
                    }
                }
            });
            

            currentPlaySession.initialSeekPerformed = false; // 重置标志以允许新的初始跳转
            // 添加 video:canplay 事件处理，确保视频准备好播放后处理跳过片头
            art.on('video:canplay', async () => {

                if (!currentPlaySession || currentPlaySession.id !== sessionId) {
                    return;
                }

                // 防止重复触发
                if (currentPlaySession.canplayHandled) {
                    return;
                }
                currentPlaySession.canplayHandled = true;

                // 处理跳过片头（先跳转）
                if (playerSettings.skipStart > 0) {
                    if (typeof art.seek === 'function') {
                        art.seek(playerSettings.skipStart);
                    } else {
                        art.currentTime = playerSettings.skipStart;
                    }
                }
                
                // 自动加载第一个字幕
                if (subtitleState.availableSubtitles.length > 0) {
                    const select = document.getElementById('subtitleSelect');
                    if (select) {
                        select.value = subtitleState.availableSubtitles[0].id;
                        await loadSubtitleToPlayer(subtitleState.availableSubtitles[0], sessionId);
                        subtitleState.currentSubtitleId = subtitleState.availableSubtitles[0].id;
                    }
                }
                
                // 应用保存的字幕样式设置
                applySubtitleSettings();
                
                // 确保播放（后播放，避免视觉闪烁）
                if (!art.playing) {
                    art.play();
                }
            });

            // 播放器错误处理（仅对当前会话生效，避免旧实例销毁时短暂覆盖 UI）
            art.on('error', (error) => {
                if (!currentPlaySession || currentPlaySession.id !== sessionId) {
                    return;
                }
                console.error('ArtPlayer error:', error);
                const artplayerContainerInner = document.getElementById('artplayer');
                if (artplayerContainerInner) {
                    artplayerContainerInner.innerHTML = `
                        <div class="video-loading-overlay" style="background-color: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center;">
                            <button class="close-video-btn" onclick="closeVideoPlayer()">&times;</button>
                            <i class="bi bi-exclamation-triangle mb-3" style="font-size: 3rem; color: #f85149;"></i>
                            <h5>播放错误</h5>
                            <p class="text-muted">${error.message || '未知错误'}</p>
                        </div>
                    `;
                }
            });

            // 添加全屏变化事件监听
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('msfullscreenchange', handleFullscreenChange);
        })
        .catch(error => {
            // 如果会话已失效或被新的点击替代，忽略错误
            if (!currentPlaySession || currentPlaySession.id !== sessionId) {
                return;
            }

            // 主动取消请求的场景，静默处理
            if (error.message === 'Request canceled') {
                return;
            }

            // 显示错误信息
            currentPlaySession.state = 'FallbackError';
            const artplayerContainer = document.getElementById('artplayer');
            if (artplayerContainer) {
                artplayerContainer.innerHTML = `
                    <div class="video-loading-overlay" style="background-color: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center;">
                        <button class="close-video-btn" onclick="closeVideoPlayer()">&times;</button>
                        <i class="bi bi-exclamation-triangle mb-3" style="font-size: 3rem; color: #f85149;"></i>
                        <h5>获取视频地址失败</h5>
                        <p class="text-muted">${error.message}</p>
                    </div>
                `;
            }
        })
        .finally(() => {
            // 只在当前会话仍然有效时更新状态
            if (!currentPlaySession || currentPlaySession.id !== sessionId) {
                return;
            }
            isRequestingVideo = false;
        });


}



// 排序方式名称映射
const sortTypeNames = {
    'name': '按名称排序',
    'structure': '按结构排序',
    'episode': '按集号排序'
};

// 更新排序按钮文本
function updateSortButton(sortType) {
    const btn = document.getElementById('sortTypeDropdown');
    if (btn) {
        btn.innerHTML = `<i class="bi bi-sort-down"></i> ${sortTypeNames[sortType] || sortTypeNames['name']}`;
    }
}

// 加载排序设置
function loadSortSettings() {
    const saved = localStorage.getItem('quark_library_sort');
    if (saved) {
        try {
            const parsed = JSON.parse(saved);
            if (parsed.sortType && ['name', 'structure', 'episode'].includes(parsed.sortType)) {
                fileSorter.setSortType(parsed.sortType);
                updateSortButton(parsed.sortType);
            }
        } catch (e) {
            console.error('Failed to parse sort settings', e);
        }
    }
}

// 保存排序设置
function saveSortSettings(sortType) {
    localStorage.setItem('quark_library_sort', JSON.stringify({ sortType: sortType }));
}

function loadPlayerSettings() {
    const saved = localStorage.getItem('quark_player_settings');
    if (saved) {
        try {
            const parsed = JSON.parse(saved);
            playerSettings = { ...playerSettings, ...parsed };
        } catch (e) {
            console.error('Failed to parse player settings', e);
        }
    }
}

function updatePlayerSetting(key, value) {
    if (key === 'skipStart' || key === 'skipEnd') {
        value = parseInt(value) || 0;
    }
    playerSettings[key] = value;
    localStorage.setItem('quark_player_settings', JSON.stringify(playerSettings));
}

playNextVideoTime = 0;
function playNextVideo(currentFileName) {
    nowTime = Date.now();
    if (nowTime - playNextVideoTime < 150) {
        console.log('playNextVideo called too quickly, ignoring.');
        return;
    }
    playNextVideoTime = nowTime;
    // 检查 ArtPlayer 实例是否存在
    if (!art) {
        console.error('ArtPlayer instance not found, falling back to playVideo');
        playVideo(currentFileName);
        return;
    }
    
    // 找到当前目录下的所有视频文件（从已排序的 currentFiles 中获取）
    const videoFiles = currentFiles.filter(file => !file.is_dir && isVideoFile(file.name));
    
    // 【修改】不再重新排序，直接使用 currentFiles 中的顺序
    const currentIndex = videoFiles.findIndex(f => f.name === currentFileName);
    
    if (currentIndex !== -1 && currentIndex < videoFiles.length - 1) {
        const nextFile = videoFiles[currentIndex + 1];
        console.log('Auto playing next video:', nextFile.name);
        
        // 获取下一个视频的下载链接
        const nextPath = currentPath === '/' ? `/${nextFile.name}` : `${currentPath}/${nextFile.name}`;
        
        // 显示加载状态
        const loadingOverlay = showLoadingOverlay('正在加载下一个视频...');
        
        // 获取下一个视频的链接
        getVideoDownloadUrl(nextPath)
            .then(async ({ url: downloadUrl, isM3U8 }) => {
                if (art) {
                    // 移除加载状态
                    if (loadingOverlay && loadingOverlay.parentNode) {
                        loadingOverlay.parentNode.removeChild(loadingOverlay);
                    }
                    
                    // 更新当前播放文件和信息
                    currentPlayFile = nextFile.name;
                    updateVideoInfo(nextFile.name);

                    // 加载新视频的字幕
                    const nextSubtitles = findMatchingSubtitles(nextFile.name);
                    subtitleState.availableSubtitles = nextSubtitles;
                    // 使用当前播放会话的 sessionId，确保字幕操作不会因 sessionId 不匹配而被取消
                    initSubtitleSelector(nextSubtitles, sessionId);

                    if (nextSubtitles.length > 0) {
                        loadSubtitleToPlayer(nextSubtitles[0], sessionId);
                    }
                    
                    // 更新播放会话信息
                    if (currentPlaySession) {
                        currentPlaySession.path = nextPath;
                        currentPlaySession.fileName = nextFile.name;
                        currentPlaySession.initialSeekPerformed = false; // 重置标志以允许新的初始跳转
                        currentPlaySession.canplayHandled = false; // 重置标志以允许新的 canplay 事件处理
                    }
                    
                    // 使用 ArtPlayer 的 switchUrl 方法切换视频
                    
                    // 清理旧的HLS实例
                    if (art.hls) {
                        art.hls.destroy();
                        art.hls = null;
                    }
                    
                    // 只调用 switchUrl，让 video:canplay 事件处理播放
                    art.switchUrl(downloadUrl, isM3U8 ? 'm3u8' : 'auto');

                } else {
                    console.error('ArtPlayer instance not found');
                    // 移除加载状态
                    if (loadingOverlay && loadingOverlay.parentNode) {
                        loadingOverlay.parentNode.removeChild(loadingOverlay);
                    }
                    // 回退到原始方案
                    playVideo(nextFile.name);
                }
            })
            .catch(error => {
                console.error('Error getting next video URL:', error);
                // 移除加载状态
                if (loadingOverlay && loadingOverlay.parentNode) {
                    loadingOverlay.parentNode.removeChild(loadingOverlay);
                }
                // 回退到原始方案
                playVideo(nextFile.name);
            });
    } else {
        console.log('No next video found or last video reached.');
        // 可以在这里添加播放结束的逻辑，比如显示结束界面
    }
}



function closeVideoPlayer() {
    // 取消字幕操作
    cancelSubtitleOperations();

    // 标记为非播放状态，允许恢复文件网格渲染
    isVideoPlaying = false;
    isRequestingVideo = false;
    currentPlayFile = null;

    // 如果有正在进行的视频请求，取消它
    cancelCurrentVideoRequest('User closed player');

    // 销毁ArtPlayer实例以释放视频资源
    destroyCurrentPlayer();

    // 移除全屏事件监听器
    document.removeEventListener('fullscreenchange', handleFullscreenChange);
    document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
    document.removeEventListener('msfullscreenchange', handleFullscreenChange);

    // 使当前会话失效
    currentPlaySession = null;

    // 清理其他可能的资源
    const artplayerContainer = document.getElementById('artplayer');
    if (artplayerContainer) {
        artplayerContainer.innerHTML = ''; // 清空容器内容
    }

    // 重新显示文件网格
    displayFileGrid(currentFiles);
}

// 处理全屏变化事件
function handleFullscreenChange() {
    const videoContainer = document.querySelector('.video-container');
    if (!videoContainer) return;

    if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
        // 进入全屏
        videoContainer.classList.add('is-fullscreen');
    } else {
        // 退出全屏
        videoContainer.classList.remove('is-fullscreen');
    }
}

function getFileIcon(fileName) {
    const ext = fileName.split('.').pop().toLowerCase();
    const iconMap = {
        'mp4': 'bi-film',
        'mkv': 'bi-film',
        'avi': 'bi-film',
        'mov': 'bi-film',
        'wmv': 'bi-film',
        'flv': 'bi-film',
        'webm': 'bi-film',
        'm4v': 'bi-film',
        'txt': 'bi-file-text',
        'pdf': 'bi-file-pdf',
        'doc': 'bi-file-word',
        'docx': 'bi-file-word',
        'xls': 'bi-file-excel',
        'xlsx': 'bi-file-excel',
        'ppt': 'bi-file-ppt',
        'pptx': 'bi-file-ppt',
        'jpg': 'bi-file-image',
        'jpeg': 'bi-file-image',
        'png': 'bi-file-image',
        'gif': 'bi-file-image',
        'zip': 'bi-file-zip',
        'rar': 'bi-file-zip',
        '7z': 'bi-file-zip'
    };
    return iconMap[ext] || 'bi-file-earmark';
}

function isVideoFile(fileName) {
    const videoExts = ['mp4', 'mkv', 'avi', 'mov', 'wmv', 'flv', 'webm', 'm4v', 'ts', 'rmvb', '3gp', 'mpg', 'mpeg', 'm3u8'];
    const ext = fileName.split('.').pop().toLowerCase();
    return videoExts.includes(ext);
}

function formatBytes(bytes) {
    if (bytes === 0) return '0 字节';
    const k = 1024;
    const sizes = ['字节', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function showError(message) {
    console.error('Library error:', message);
    const fileList = document.getElementById('fileList');
    const contentArea = document.getElementById('contentArea');

    // Clear the main content grid
    contentArea.innerHTML = '';

    // Display error in the file list sidebar
    fileList.innerHTML = `
        <div class="error-message p-3 text-center">
            <i class="bi bi-exclamation-triangle mb-2" style="font-size: 2rem;"></i>
            <p>${message}</p>
            <p class="text-muted small">Please check the browser console for more information</p>
            <button class="btn btn-sm btn-outline-primary mt-2" onclick="loadFileList(currentPath, true);">
                <i class="bi bi-arrow-clockwise"></i> Retry
            </button>
        </div>
    `;
}

function handleFileSelection() {
    selectedFiles.clear();
    document.querySelectorAll('.file-checkbox:checked').forEach(checkbox => {
        selectedFiles.add(checkbox.value);
    });
    updateDeleteButtonState();

    const allCheckboxes = document.querySelectorAll('.file-checkbox');
    const selectAllCheckbox = document.getElementById('selectAllCheckbox');
    selectAllCheckbox.checked = allCheckboxes.length > 0 && selectedFiles.size === allCheckboxes.length;
}

function updateDeleteButtonState() {
    const deleteBtn = document.getElementById('deleteBtn');
    deleteBtn.disabled = selectedFiles.size === 0;
}

function toggleSelectAll() {
    const isChecked = document.getElementById('selectAllCheckbox').checked;
    document.querySelectorAll('.file-checkbox').forEach(checkbox => {
        checkbox.checked = isChecked;
    });
    handleFileSelection();
}

function deleteSelectedFiles() {
    const filesToDelete = Array.from(selectedFiles);
    if (filesToDelete.length === 0) {
        return;
    }

    if (!confirm(`您确定要删除选中的 ${filesToDelete.length} 个项目吗？此操作无法撤销。`)) {
        return;
    }

    const pathsToDelete = filesToDelete.map(fileName => {
        return currentPath === '/' ? `/${fileName}` : `${currentPath}/${fileName}`;
    });

    axios.post('/api/library/fs/delete', { paths: pathsToDelete })
        .then(response => {
            if (response.data.success) {
                console.log('Files deleted successfully');
                loadFileList(currentPath, true); // 强制刷新
            } else {
                showError('Failed to delete: ' + response.data.message);
            }
        })
        .catch(error => {
            console.error('Error deleting files:', error);
            showError('Error while deleting');
        });
}

function displayFileGrid(files) {
    if (isVideoPlaying) {
        return;
    }
    const contentArea = document.getElementById('contentArea');
    
    if (files.length === 0) {
        contentArea.innerHTML = `
            <div class="d-flex justify-content-center align-items-center h-100">
                <div class="text-center">
                    <i class="bi bi-folder-x" style="font-size: 5rem; color: #8B949E;"></i>
                    <p class="text-muted">空目录</p>
                </div>
            </div>
        `;
        return;
    }
    
    // 只显示视频文件
    const videoFiles = files.filter(file => !file.is_dir && isVideoFile(file.name));
    
    if (videoFiles.length === 0) {
        contentArea.innerHTML = `
            <div class="d-flex justify-content-center align-items-center h-100">
                <div class="text-center">
                    <i class="bi bi-film" style="font-size: 5rem; color: #8B949E;"></i>
                    <p class="text-muted">此目录中没有视频文件</p>
                </div>
            </div>
        `;
        return;
    }
    
    // 使用全局计算的公共子串
    // const commonSubstrings = currentVideoCommonSubstrings;
    
    let html = '<div class="file-grid">';
    
    videoFiles.forEach(file => {
        // 使用 fileSorter.highlightFileName 函数处理文件名
        const nameResult = fileSorter.highlightFileName(file.name);
        const displayHtml = typeof nameResult === 'string' ? nameResult : nameResult.html;
        const displayTitle = typeof nameResult === 'string' ? file.name : nameResult.title;
        
        html += `
            <div class="file-card video-card" onclick="playVideo('${file.name}')">
                <div class="file-icon">
                    <i class="bi ${getFileIcon(file.name)}"></i>
                </div>
                <div class="play-overlay">
                    <i class="bi bi-play-fill"></i>
                </div>
                <div class="file-name" title="${displayTitle}">${displayHtml}</div>
                <div class="file-size">${formatBytes(file.size)}</div>
            </div>
        `;
    });
    
    html += '</div>';
    contentArea.innerHTML = html;
}
</script>

